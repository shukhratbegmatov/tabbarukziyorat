{
  "version": 3,
  "sources": ["../../highlight-words-core/dist/webpack:/webpack/bootstrap 2a95070affdf3c0054f1", "../../highlight-words-core/dist/webpack:/src/index.js", "../../highlight-words-core/dist/webpack:/src/utils.js", "../../vue-highlight-words/dist/vue-highlight-words.esm.js"],
  "sourcesContent": [" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2a95070affdf3c0054f1", "// @flow\n\nexport { combineChunks, fillInChunks, findAll, findChunks } from './utils'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js", "// @flow\n\nexport type Chunk = {|\n  highlight: boolean,\n  start: number,\n  end: number,\n|};\n\n/**\n * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n */\nexport const findAll = ({\n  autoEscape,\n  caseSensitive = false,\n  findChunks = defaultFindChunks,\n  sanitize,\n  searchWords,\n  textToHighlight\n}: {\n  autoEscape?: boolean,\n  caseSensitive?: boolean,\n  findChunks?: typeof defaultFindChunks,\n  sanitize?: typeof defaultSanitize,\n  searchWords: Array<string>,\n  textToHighlight: string,\n}): Array<Chunk> => (\n  fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape,\n        caseSensitive,\n        sanitize,\n        searchWords,\n        textToHighlight\n      })\n    }),\n    totalLength: textToHighlight ? textToHighlight.length : 0\n  })\n)\n\n/**\n * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n * @return {start:number, end:number}[]\n */\nexport const combineChunks = ({\n  chunks\n}: {\n  chunks: Array<Chunk>,\n}): Array<Chunk> => {\n  chunks = chunks\n    .sort((first, second) => first.start - second.start)\n    .reduce((processedChunks, nextChunk) => {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk]\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        const prevChunk = processedChunks.pop()\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          const endIndex = Math.max(prevChunk.end, nextChunk.end)\n          processedChunks.push({highlight: false, start: prevChunk.start, end: endIndex})\n        } else {\n          processedChunks.push(prevChunk, nextChunk)\n        }\n        return processedChunks\n      }\n    }, [])\n\n  return chunks\n}\n\n/**\n * Examine text for any matches.\n * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n * @return {start:number, end:number}[]\n */\nconst defaultFindChunks = ({\n  autoEscape,\n  caseSensitive,\n  sanitize = defaultSanitize,\n  searchWords,\n  textToHighlight\n}: {\n  autoEscape?: boolean,\n  caseSensitive?: boolean,\n  sanitize?: typeof defaultSanitize,\n  searchWords: Array<string>,\n  textToHighlight: string,\n}): Array<Chunk> => {\n  textToHighlight = sanitize(textToHighlight)\n\n  return searchWords\n    .filter(searchWord => searchWord) // Remove empty words\n    .reduce((chunks, searchWord) => {\n      searchWord = sanitize(searchWord)\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord)\n      }\n\n      const regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi')\n\n      let match\n      while ((match = regex.exec(textToHighlight))) {\n        let start = match.index\n        let end = regex.lastIndex\n        // We do not return zero-length matches\n        if (end > start) {\n          chunks.push({highlight: false, start, end})\n        }\n\n        // Prevent browsers like Firefox from getting stuck in an infinite loop\n        // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++\n        }\n      }\n\n      return chunks\n    }, [])\n}\n// Allow the findChunks to be overridden in findAll,\n// but for backwards compatibility we export as the old name\nexport {defaultFindChunks as findChunks}\n\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n * @param chunksToHighlight {start:number, end:number}[]\n * @param totalLength number\n * @return {start:number, end:number, highlight:boolean}[]\n */\nexport const fillInChunks = ({\n  chunksToHighlight,\n  totalLength\n}: {\n  chunksToHighlight: Array<Chunk>,\n  totalLength: number,\n}): Array<Chunk> => {\n  const allChunks = []\n  const append = (start, end, highlight) => {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      })\n    }\n  }\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false)\n  } else {\n    let lastIndex = 0\n    chunksToHighlight.forEach((chunk) => {\n      append(lastIndex, chunk.start, false)\n      append(chunk.start, chunk.end, true)\n      lastIndex = chunk.end\n    })\n    append(lastIndex, totalLength, false)\n  }\n  return allChunks\n}\n\nfunction defaultSanitize (string: string): string {\n  return string\n}\n\nfunction escapeRegExpFn (string: string): string {\n  return string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js", "\n/*!\n * vue-highlight-words  v3.0.1\n * Â© 2022 Yichang Liu\n * LICENCE: MIT\n*/\n\nimport { findAll } from 'highlight-words-core';\nimport { h } from 'vue';\n\nconst VueHighlightWordsImpl = (props, context) => {\r\n    const chunks = findAll({\r\n        autoEscape: props.autoEscape,\r\n        caseSensitive: props.caseSensitive,\r\n        findChunks: props.findChunks,\r\n        sanitize: props.sanitize,\r\n        searchWords: props.searchWords,\r\n        textToHighlight: props.textToHighlight,\r\n    });\r\n    const children = getTextChildren(props, chunks);\r\n    const slots = context.slots;\r\n    if (slots.default) {\r\n        return slots.default && slots.default(children);\r\n    }\r\n    return h('span', { ...context.attrs }, children.map(({ chunk, text, attrs }) => {\r\n        if (!chunk.highlight) {\r\n            return text;\r\n        }\r\n        return h('mark', attrs, [text]);\r\n    }));\r\n};\r\nconst EMPTY_STYLE = {};\r\nfunction getTextChildren(props, chunks) {\r\n    let highlightCount = -1;\r\n    let highlightClassNames = '';\r\n    let highlightStyles = {};\r\n    const { textToHighlight, highlightClassName, highlightStyle = EMPTY_STYLE, activeIndex, activeClassName, activeStyle = EMPTY_STYLE, } = props;\r\n    return chunks.map((chunk, index) => {\r\n        const text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);\r\n        if (!chunk.highlight) {\r\n            return { chunk, text };\r\n        }\r\n        else {\r\n            highlightCount++; // start at 0\r\n            const isActive = highlightCount === +(activeIndex || -1);\r\n            highlightClassNames = `${highlightClassName} ${isActive ? activeClassName : ''}`;\r\n            highlightStyles =\r\n                isActive === true && activeStyle != null\r\n                    ? { ...highlightStyle, ...activeStyle }\r\n                    : highlightStyle;\r\n            const attrs = {\r\n                class: highlightClassNames,\r\n                key: index,\r\n                style: highlightStyles,\r\n                highlightIndex: highlightCount,\r\n            };\r\n            return { chunk, text, attrs };\r\n        }\r\n    });\r\n}\r\nVueHighlightWordsImpl.props = {\r\n    activeClassName: String,\r\n    activeIndex: Number,\r\n    activeStyle: Object,\r\n    autoEscape: Boolean,\r\n    caseSensitive: {\r\n        type: Boolean,\r\n        defualt: false,\r\n    },\r\n    findChunks: Function,\r\n    custom: {\r\n        type: Boolean,\r\n        default: false,\r\n    },\r\n    highlightClassName: String,\r\n    highlightStyle: Object,\r\n    sanitize: Function,\r\n    searchWords: {\r\n        type: Array,\r\n        validator(value) {\r\n            return value.every((word) => typeof word === 'string');\r\n        },\r\n        required: true,\r\n    },\r\n    textToHighlight: {\r\n        type: String,\r\n        required: true,\r\n    },\r\n};\r\nconst VueHighlightWords = VueHighlightWordsImpl;\n\nfunction install(app, options = { name: '' }) {\r\n    app.component(options.name || 'VueHighlightWords', VueHighlightWords);\r\n}\n\nexport { VueHighlightWords, VueHighlightWords as default, install };\n"],
  "mappings": ";;;;;;;;;;;;;;AACA,UAAA,mBAAA,CAAA;AAGA,eAAA,oBAAA,UAAA;AAGA,YAAA,iBAAA,QAAA;AACA,iBAAA,iBAAA,QAAA,EAAA;AAGA,YAAAA,UAAA,iBAAA,QAAA,IAAA;;UACA,SAAA,CAAA;;UACA,IAAA;;UACA,QAAA;;QACA;AAGA,gBAAA,QAAA,EAAA,KAAAA,QAAA,SAAAA,SAAAA,QAAA,SAAA,mBAAA;AAGA,QAAAA,QAAA,SAAA;AAGA,eAAAA,QAAA;MACA;AAIA,0BAAA,IAAA;AAGA,0BAAA,IAAA;AAGA,0BAAA,IAAA;AAGA,aAAA,oBAAA,CAAA;;;;;;;;;;;;;;;;;;0BCpCSC;;;;;;0BAAeC;;;;;;0BAAcC;;;;;;0BAASC;;;;;;;;;;;ACUxC,YAAMD,WAAAA,SAAAA,UAAU,SAAVA,SAAU,MAAA;AAAA,cACrBE,aADqB,KACrBA,YADqB,qBAAA,KAErBC,eAAAA,gBAFqB,uBAAA,SAEL,QAFK,oBAAA,kBAAA,KAGrBF,YAAAA,aAHqB,oBAAA,SAGRG,oBAHQ,iBAIrBC,WAJqB,KAIrBA,UACAC,cALqB,KAKrBA,aACAC,kBANqB,KAMrBA;AANqB,iBAerBR,aAAa;YACXS,mBAAmBV,cAAc;cAC/BW,QAAQR,WAAW;gBACjBC;gBACAC;gBACAE;gBACAC;gBACAC;cALiB,CAAX;YADuB,CAAd;YASnBG,aAAaH,kBAAkBA,gBAAgBI,SAAS;UAV7C,CAAb;QAfqB;AAiChB,YAAMb,gBAAAA,SAAAA,gBAAgB,SAAhBA,eAAgB,OAIT;AAAA,cAHlBW,SAGkB,MAHlBA;AAIAA,mBAASA,OACNG,KAAK,SAACC,OAAOC,QAAR;AAAA,mBAAmBD,MAAME,QAAQD,OAAOC;UAAxC,CADC,EAENC,OAAO,SAACC,iBAAiBC,WAAc;AAEtC,gBAAID,gBAAgBN,WAAW,GAAG;AAChC,qBAAO,CAACO,SAAD;YACR,OAAM;AAEL,kBAAMC,YAAYF,gBAAgBG,IAAhB;AAClB,kBAAIF,UAAUH,SAASI,UAAUE,KAAK;AAGpC,oBAAMC,WAAWC,KAAKC,IAAIL,UAAUE,KAAKH,UAAUG,GAAlC;AACjBJ,gCAAgBQ,KAAK,EAACC,WAAW,OAAOX,OAAOI,UAAUJ,OAAOM,KAAKC,SAAhD,CAArB;cACD,OAAM;AACLL,gCAAgBQ,KAAKN,WAAWD,SAAhC;cACD;AACD,qBAAOD;YACR;UACF,GAAE,CAAA,CAnBI;AAqBT,iBAAOR;QACR;AAOD,YAAML,oBAAoB,SAApBA,mBAAoB,OAYN;AAAA,cAXlBF,aAWkB,MAXlBA,YACAC,gBAUkB,MAVlBA,eAUkB,iBAAA,MATlBE,UAAAA,WASkB,mBAAA,SATPsB,kBASO,gBARlBrB,cAQkB,MARlBA,aACAC,kBAOkB,MAPlBA;AAQAA,4BAAkBF,SAASE,eAAT;AAElB,iBAAOD,YACJsB,OAAO,SAAA,YAAA;AAAA,mBAAcC;UAAd,CADH,EAEJb,OAAO,SAACP,QAAQoB,YAAe;AAC9BA,yBAAaxB,SAASwB,UAAT;AAEb,gBAAI3B,YAAY;AACd2B,2BAAaC,eAAeD,UAAf;YACd;AAED,gBAAME,QAAQ,IAAIC,OAAOH,YAAY1B,gBAAgB,MAAM,IAA7C;AAEd,gBAAI8B,QAAAA;AACJ,mBAAQA,QAAQF,MAAMG,KAAK3B,eAAX,GAA8B;AAC5C,kBAAIQ,SAAQkB,MAAME;AAClB,kBAAId,OAAMU,MAAMK;AAEhB,kBAAIf,OAAMN,QAAO;AACfN,uBAAOgB,KAAK,EAACC,WAAW,OAAOX,OAAAA,QAAOM,KAAAA,KAA1B,CAAZ;cACD;AAID,kBAAIY,MAAME,UAAUJ,MAAMK,WAAW;AACnCL,sBAAMK;cACP;YACF;AAED,mBAAO3B;UACR,GAAE,CAAA,CA5BE;QA6BR;iBAG4BR,aAArBG;AASD,YAAML,eAAAA,SAAAA,eAAe,SAAfA,cAAe,OAMR;AAAA,cALlBS,oBAKkB,MALlBA,mBACAE,cAIkB,MAJlBA;AAKA,cAAM2B,YAAY,CAAA;AAClB,cAAMC,SAAS,SAATA,QAAUvB,OAAOM,KAAKK,WAAc;AACxC,gBAAIL,MAAMN,QAAQ,GAAG;AACnBsB,wBAAUZ,KAAK;gBACbV;gBACAM;gBACAK;cAHa,CAAf;YAKD;UACF;AAED,cAAIlB,kBAAkBG,WAAW,GAAG;AAClC2B,mBAAO,GAAG5B,aAAa,KAAvB;UACD,OAAM;AACL,gBAAI0B,YAAY;AAChB5B,8BAAkB+B,QAAQ,SAACC,OAAU;AACnCF,qBAAOF,WAAWI,MAAMzB,OAAO,KAA/B;AACAuB,qBAAOE,MAAMzB,OAAOyB,MAAMnB,KAAK,IAA/B;AACAe,0BAAYI,MAAMnB;YACnB,CAJD;AAKAiB,mBAAOF,WAAW1B,aAAa,KAA/B;UACD;AACD,iBAAO2B;QACR;AAED,iBAASV,gBAAiBc,QAAwB;AAChD,iBAAOA;QACR;AAED,iBAASX,eAAgBW,QAAwB;AAC/C,iBAAOA,OAAOC,QAAQ,uCAAuC,MAAtD;QACR;;;;;;;;ACtKD,kCAAwB;AAGxB,IAAM,wBAAwB,CAAC,OAAO,YAAY;AAC9C,QAAM,aAAS,qCAAQ;AAAA,IACnB,YAAY,MAAM;AAAA,IAClB,eAAe,MAAM;AAAA,IACrB,YAAY,MAAM;AAAA,IAClB,UAAU,MAAM;AAAA,IAChB,aAAa,MAAM;AAAA,IACnB,iBAAiB,MAAM;AAAA,EAC3B,CAAC;AACD,QAAM,WAAW,gBAAgB,OAAO,MAAM;AAC9C,QAAM,QAAQ,QAAQ;AACtB,MAAI,MAAM,SAAS;AACf,WAAO,MAAM,WAAW,MAAM,QAAQ,QAAQ;AAAA,EAClD;AACA,SAAO,EAAE,QAAQ,EAAE,GAAG,QAAQ,MAAM,GAAG,SAAS,IAAI,CAAC,EAAE,OAAO,MAAM,MAAM,MAAM;AAC5E,QAAI,CAAC,MAAM,WAAW;AAClB,aAAO;AAAA,IACX;AACA,WAAO,EAAE,QAAQ,OAAO,CAAC,IAAI,CAAC;AAAA,EAClC,CAAC,CAAC;AACN;AACA,IAAM,cAAc,CAAC;AACrB,SAAS,gBAAgB,OAAO,QAAQ;AACpC,MAAI,iBAAiB;AACrB,MAAI,sBAAsB;AAC1B,MAAI,kBAAkB,CAAC;AACvB,QAAM,EAAE,iBAAiB,oBAAoB,iBAAiB,aAAa,aAAa,iBAAiB,cAAc,YAAa,IAAI;AACxI,SAAO,OAAO,IAAI,CAAC,OAAO,UAAU;AAChC,UAAM,OAAO,gBAAgB,OAAO,MAAM,OAAO,MAAM,MAAM,MAAM,KAAK;AACxE,QAAI,CAAC,MAAM,WAAW;AAClB,aAAO,EAAE,OAAO,KAAK;AAAA,IACzB,OACK;AACD;AACA,YAAM,WAAW,mBAAmB,EAAE,eAAe;AACrD,4BAAsB,GAAG,sBAAsB,WAAW,kBAAkB;AAC5E,wBACI,aAAa,QAAQ,eAAe,OAC9B,EAAE,GAAG,gBAAgB,GAAG,YAAY,IACpC;AACV,YAAM,QAAQ;AAAA,QACV,OAAO;AAAA,QACP,KAAK;AAAA,QACL,OAAO;AAAA,QACP,gBAAgB;AAAA,MACpB;AACA,aAAO,EAAE,OAAO,MAAM,MAAM;AAAA,IAChC;AAAA,EACJ,CAAC;AACL;AACA,sBAAsB,QAAQ;AAAA,EAC1B,iBAAiB;AAAA,EACjB,aAAa;AAAA,EACb,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,eAAe;AAAA,IACX,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACA,YAAY;AAAA,EACZ,QAAQ;AAAA,IACJ,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACA,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,UAAU;AAAA,EACV,aAAa;AAAA,IACT,MAAM;AAAA,IACN,UAAU,OAAO;AACb,aAAO,MAAM,MAAM,CAAC,SAAS,OAAO,SAAS,QAAQ;AAAA,IACzD;AAAA,IACA,UAAU;AAAA,EACd;AAAA,EACA,iBAAiB;AAAA,IACb,MAAM;AAAA,IACN,UAAU;AAAA,EACd;AACJ;AACA,IAAM,oBAAoB;AAE1B,SAAS,QAAQ,KAAK,UAAU,EAAE,MAAM,GAAG,GAAG;AAC1C,MAAI,UAAU,QAAQ,QAAQ,qBAAqB,iBAAiB;AACxE;",
  "names": ["module", "combineChunks", "fillInChunks", "findAll", "findChunks", "autoEscape", "caseSensitive", "defaultFindChunks", "sanitize", "searchWords", "textToHighlight", "chunksToHighlight", "chunks", "totalLength", "length", "sort", "first", "second", "start", "reduce", "processedChunks", "nextChunk", "prevChunk", "pop", "end", "endIndex", "Math", "max", "push", "highlight", "defaultSanitize", "filter", "searchWord", "escapeRegExpFn", "regex", "RegExp", "match", "exec", "index", "lastIndex", "allChunks", "append", "forEach", "chunk", "string", "replace"]
}
